//
//  NetlifyBlogPostsMigration.swift
//  aPrincipalEngineer
//
//  Created by Tyler Thompson on 12/3/24.
//

import Fluent
import Foundation

struct NetlifyBlogPostsMigration: AsyncMigration {
    enum MigrationError: Error {
        case cannotFindTyler
    }
    func prepare(on database: any Database) async throws {
        let prodTyler = try await User.find(UUID(uuidString: "c6b2b5d9-cfcf-4d5d-b818-12d9e4fcd6c3"), on: database)
        let debugTyler = try await User.find(UUID(uuidString: "6D50873A-D6EE-4B1E-9ADF-99067B2B4467"), on: database)
        guard let tyler = prodTyler ?? debugTyler else { throw MigrationError.cannotFindTyler }

//        1665046f-18ba-4005-9122-b708a28640dc
//        de43ae83-2feb-4b2f-9a7d-25f6078fb547
//        fa44f008-9f2e-4152-af22-c9359d1d206c
//        4d4b70cc-1bbd-4505-a40e-33376d494302
//        fde72d71-6b59-49a6-bca5-419c12835348
//        733037c5-960e-4ed8-8190-d1fd72fb24d6
//        bc561082-a34b-4a53-8877-dec62d28ffd8
        let engineering = Tag(id: UUID(uuidString: "75642bd6-f139-4c4a-b77e-3e93a5dcaab4"), canonicalTitle: "engineering")
        try await engineering.save(on: database)
        let testing = Tag(id: UUID(uuidString: "9a2e3819-bade-418a-abde-15f947452b67"), canonicalTitle: "testing")
        try await testing.save(on: database)
        let swift = Tag(id: UUID(uuidString: "4926c474-487f-4b6f-8c9f-862026a5d005"), canonicalTitle: "swift")
        try await swift.save(on: database)

        let restNetworkingLayer = BlogPost(id: UUID(uuidString: "b35c209e-d2c1-475b-86af-333294c9407e"),
                                           status: .published,
                                           title: "A Great REST Networking Layer",
                                           createdAt: Date(timeIntervalSince1970: 1667151000), // 2022-10-30 11:30
                                           description: "I walk through my favorite REST networking layer, and why I prefer it.",
                                           content: "## Motivation\nA great networking layer is hard to come by. Some people pull in 3rd party dependencies with interceptors and lots of layers of abstraction, and some just use `URLSession` and GCD. I personally don't like either option, at least for simple REST calls. This article will be a bit long, but I'll walk you through my preferred networking layer and explain why I like it.\n\n> NOTE: All code for this example can be found [on my GitHub random projects page](https://github.com/Tyler-Keith-Thompson/RandomSideProjects/tree/main/RESTNetworkLayer)\n\n## GCD, Combine, or Async/Await\nLet's be honest, Grand Central Dispatch (GCD) is kind of a mess. The closure-based APIs aren't very friendly and they're error-prone. Most people who write asynchronous operations using GCD don't even consider cancellation. GCD's quirkiness is why you see network layers with interceptor patterns. This was fine a few years ago, but I think we can do better.\n\n`async/await` is [fraught](https://wojciechkulik.pl/ios/swift-concurrency-things-they-dont-tell-you?utm_campaign=iOS%2BDev%2BWeekly&utm_medium=web&utm_source=iOS%2BDev%2BWeekly%2BIssue%2B582) [with](https://swiftsenpai.com/swift/actor-reentrancy-problem/) [perils](https://alejandromp.com/blog/the-importance-of-cooperative-cancellation/) and people don't often immediately notice them. This is especially true with the cooperative cancellation paradigm, which requires you to be smart about checking whether a task has been cancelled frequently (ideally, after every `await` boundary).\n\nThis is why I prefer Combine, Apple's reactive framework. Its declarative interface, cancellation model, and flexibility with [backpressure](https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7) are incredibly useful when designing a networking layer. I would argue that it is still preferable to `async/await`. Although I would use `async/await` for on-device concurrency concerns.\n\nWhat's more, Combine forces users to store an `AnyCancellable`, and the most common methods of storing them result in appropriate cancellation. For example, if you store a `Set<AnyCanellable>` on a `UIViewController` or SwiftUI `@StateObject`, they are all cancelled when the view is removed from the hierarchy. So, if a user were to hit the \"back\" button in a navigation stack, for example, all ongoing requests for that view would simply cancel.\n\n## Service design\nIdeally, other parts of the code utilize the network layer [through a service](https://en.wikipedia.org/wiki/Service_(systems_architecture)). For example, if I had an API that stored and retrieved posts on a forum, I'd create a `PostService` that returned deserialized `Post` objects. Other parts of my code would ask the `PostService` for things, and it would either reach out over the network, pull from a cache, or any other number of things.\n\nTo that end, our network layer should make it easy for a service to use it with extreme flexibility, but not expose things outside of those services. I think a protocol is a great way of handling this. What if we had something like this:\n\n```\nprotocol PostService {\n    var getPosts: AnyPublisher<Result<[Post], Error>, Never> { get }\n}\n\nstruct _PostService: RESTAPIProtocol, PostService {\n    var baseURL = \"https://api.myforum.com\"\n    var getPosts: AnyPublisher<Result<[Post], Error>, Never> {\n        self.get(endpoint: \"posts\") { request in \n            request\n            .addingBearerAuthorization(accessToken: User.shared.accessToken)\n            .receivingJSON()\n        }\n        .catchHTTPErrors()\n        .catchUnauthorizedAndRetryRequestWithFreshAccessToken()\n        .map(\\.data)\n        .decode(type: [Post].self, decoder: JSONDecoder())\n        .map(Result.success)\n        .catch { Just(.failure($0)) }\n        .eraseToAnyPublisher()\n    }\n}\n```\n\nConsumers only know about `PostService` which exposes a way to get posts, but the service itself (`_PostService`) knows lots of details, like the base URL, endpoint, the fact it needs authentication, it can handle backpressure issues like receiving a 401 and retrying the request, it knows we're using REST and JSON and it knows how to deserialize into an array of `Post`. \n\n## Creating a `RESTAPIProtocol`\nOne quirk of making requests with Swift is that you get a `URLResponse` which needs to be converted into an `HTTPURLResponse` to check things like the status code. To make this easier, our protocol should return an `HTTPURLResponse`.\n\nLet's start with a simple protocol definition:\n```\nimport Foundation\nimport Combine\n\npublic protocol RESTAPIProtocol {\n    typealias ErasedHTTPDataTaskPublisher = AnyPublisher<(data: Data, response: HTTPURLResponse), Error>\n    typealias Output = ErasedHTTPDataTaskPublisher.Output\n    typealias Failure = ErasedHTTPDataTaskPublisher.Failure\n\n    var baseURL: String { get }\n    var urlSession: URLSession { get }\n}\n\n@available(iOS 13.0, macOS 11.0, tvOS 13.0, watchOS 7.0, *)\nextension RESTAPIProtocol {\n    public var urlSession: URLSession { URLSession.shared }\n\n    public func get(endpoint: String) -> ErasedHTTPDataTaskPublisher {\n        guard let url = URL(string: \"\\(baseURL)\")?.appendingPathComponent(endpoint) else {\n            return Fail<Output, Failure>(error: URLError(.badURL)).eraseToAnyPublisher()\n        }\n        var request = URLRequest(url: url)\n        request.httpMethod = \"GET\"\n        return createPublisher(for: request)\n    }\n\n    // Other verbs, put/post/patch/delete\n\n    func createPublisher(for request: URLRequest) -> ErasedHTTPDataTaskPublisher {\n        Just(request)\n            .flatMap { [urlSession] in\n                urlSession.dataTaskPublisher(for: $0)\n            }\n            .tryMap {\n                guard let res = $0.response as? HTTPURLResponse else {\n                    throw URLError(.badServerResponse)\n                }\n                return (data: $0.data, response: res)\n            }\n            .eraseToAnyPublisher()\n    }\n}\n```\n\nOur protocol now exposes a way to make `GET` requests... but it doesn't allow people to modify the outgoing request. Consumers of our protocol want 2 specific behaviors:\n\n- The ability to modify a request before it is sent.\n- If the publisher retries (like when a 401 is returned) then the request modifier should be recalculated.\n    - To expand on this idea, look at the example in our `PostService` when the publisher chain restarts the *new* access token needs to be used, not the old one.\n\nBecause `Just` is a little fiddly, anything we put in there will be cached, we need to be a little bit clever. Let's modify `RESTAPIProtocol`\n\n```\npublic protocol RESTAPIProtocol {\n    typealias RequestModifier = ((URLRequest) -> URLRequest)\n    ...\n}\n\n@available(iOS 13.0, macOS 11.0, tvOS 13.0, watchOS 7.0, *)\nextension RESTAPIProtocol {\n    ...\n\n    public func get(endpoint: String, requestModifier: @escaping RequestModifier = { $0 }) -> ErasedHTTPDataTaskPublisher {\n        ...\n        return createPublisher(for: request, requestModifier: requestModifier)\n    }\n\n    func createPublisher(for request: URLRequest, requestModifier: @escaping RequestModifier) -> ErasedHTTPDataTaskPublisher {\n        Just(request)\n            .flatMap { [urlSession] in\n                urlSession.dataTaskPublisher(for: requestModifier($0))\n            }\n            ...\n    }\n}\n```\n\nNow consumers can modify a request just like in our `PostService` example. Calculating the `requestModifier` in the `flatMap` gives us the behavior we want when the chain is restarted.\n\n## Fluent request modification\nYou may have noticed that in my proposed service, we used a [fluent API](https://en.wikipedia.org/wiki/Fluent_interface#Swift). This not only fits well with Combine, which is already fluent, but it makes it easy to compose sets of headers. Here's how we can do that:\n\n```\nextension URLRequest {\n    public func addingValue(_ value: String, forHTTPHeaderField header: String) -> URLRequest {\n        var request = self\n        request.setValue(value, forHTTPHeaderField: header)\n        return request\n    }\n}\n```\n\nThis also has the advantage of not mutating the original request, avoiding mutation where we can is generally of great benefit. You'll notice the existing `URLRequest` is copied into a new variable, then *that* is modified using Apple APIs.\n\n## Error handling\nWe can create a series of `HTTPError` types, some for 400-499 `HTTPClientError` types and some for 500-599 `HTTPServerError` types. These can even peak into a request and find standard headers that give more error info. For example, a 429 usually comes with a `Retry-After` header indicating how long you should wait before attempting the request again.\n\nOnce those error types are created, we can create a Combine modifier that handles them, here's an example:\n\n```\nextension Publisher {\n    public func catchHTTPErrors() -> Publishers.TryMap<Self, Output> where Output == RESTAPIProtocol.Output {\n        tryMap {\n            guard let err: any HTTPError = HTTPClientError(code: UInt($0.response.statusCode)) ?? HTTPServerError(code: UInt($0.response.statusCode)) else {\n                return $0\n            }\n\n            if $0.response.statusCode == 429 {\n                throw HTTPClientError.tooManyRequests(retryAfter: $0.response.retryAfter)\n            }\n\n            throw err\n        }\n    }\n}\n```\n\nUsers may also want to be able to catch specific kinds of errors, which Combine doesn't quite allow on its own. This gives them the ability to add custom logic to the request chain. Here's an example that responds to rate limiting (a 429)\n\n```\nextension Publisher {\n    public func tryCatch<E: Error & Equatable,\n                         P: Publisher>(_ error: E,\n                                       _ handler: @escaping (E) throws -> P) -> Publishers.TryCatch<Self, P> where Failure == Error {\n        tryCatch { err in\n            guard let unwrappedError = (err as? E),\n                    unwrappedError == error else { throw err }\n            return try handler(unwrappedError)\n        }\n    }\n\n    public func respondToRateLimiting(maxSecondsToWait: Double = 1) -> AnyPublisher<Output, Failure> where Output == RESTAPIProtocol.Output, Failure == Error {\n        catchHTTPErrors()\n            .tryCatch(HTTPClientError.tooManyRequests()) { err -> AnyPublisher<Output, Failure> in\n                guard case .tooManyRequests(let retryAfter) = err else {\n                    throw err // shouldn't ever really happen\n                }\n\n                let delayInSeconds: Double = {\n                    if let serverDelay = retryAfter?.converted(to: .seconds).value,\n                       serverDelay < maxSecondsToWait {\n                        return serverDelay\n                    }\n                    return maxSecondsToWait\n                }()\n\n                return Just(()).delay(for: .seconds(delayInSeconds),\n                                      scheduler: DispatchQueue.global(qos:.userInitiated),\n                                      options: nil)\n                .flatMap { _ in self.catchHTTPErrors() }\n                .eraseToAnyPublisher()\n            }\n            .eraseToAnyPublisher()\n    }\n}\n```\n\nThere are a few complicated Combine-type things to learn, but look at just how easy it is to handle rate limiting! No interceptors and complex retry logic, just a simple combination of existing Combine operators. I'll leave it as an exercise for the reader to imagine how you could add even more flexibility (like retrying on a 401) to this. Alternatively, check out [the GitHub repo](https://github.com/Tyler-Keith-Thompson/RandomSideProjects/tree/main/RESTNetworkLayer) to see an example.\n\n## Testing\nOkay, so while reactive programming might be new to people, this whole layer isn't too intimidating. But how hard is it to test? I personally use [OHTTPStubs](https://github.com/AliSoftware/OHHTTPStubs) and create my own [fluent wrapper around it](https://github.com/AliSoftware/OHHTTPStubs/issues/349) to make this dead simple.\n\nLet's start by defining a Combine test helper:\n```\nextension Publisher {\n    func firstValue(timeout: TimeInterval = 0.3,\n                    file: StaticString = #file,\n                    line: UInt = #line) async -> Result<Output, Error> where Failure == Error {\n        await withCheckedContinuation { continuation in\n            var result: Result<Output, Error>?\n            let expectation = XCTestExpectation(description: \"Awaiting publisher\")\n\n            let cancellable = map(Result<Output, Error>.success)\n                .catch { Just(.failure($0)) }\n                .sink {\n                    result = $0\n                    expectation.fulfill()\n                }\n\n            XCTWaiter().wait(for: [expectation], timeout: timeout)\n            cancellable.cancel()\n\n            do {\n                let unwrappedResult = try XCTUnwrap(\n                    result,\n                    \"Awaited publisher did not produce any output\",\n                    file: file,\n                    line: line\n                )\n                continuation.resume(returning: unwrappedResult)\n            } catch {\n                continuation.resume(returning: .failure(error))\n            }\n        }\n    }\n}\n```\n\nNow I'll show you how easy it is to test our rate-limiting logic:\n```\nimport Foundation\nimport Combine\nimport XCTest\n\nimport OHHTTPStubs\nimport OHHTTPStubsSwift\n\nimport RESTNetworkLayer\n\nfinal class HTTPOperatorsTests: XCTestCase {\n    struct JSONPlaceholder: RESTAPIProtocol {\n        var baseURL: String = \"https://jsonplaceholder.typicode.com\"\n    }\n\n    override func setUpWithError() throws {\n        HTTPStubs.removeAllStubs()\n\n        stub { _ in true } response: { req in\n            XCTFail(\"Unexpected request made: \\(req)\")\n            return HTTPStubsResponse(error: URLError.init(.badURL))\n        }\n    }\n\n    func testCatchingTooManyRequests() async throws {\n        let url = try XCTUnwrap(URL(string: \"https://www.google.com\"))\n\n        let error = HTTPClientError.tooManyRequests()\n\n        let response = try XCTUnwrap(HTTPURLResponse(url: url,\n                                                     statusCode: Int(error.statusCode),\n                                                     httpVersion: nil,\n                                                     headerFields: [\"Retry-After\": \"1.5\"]))\n\n        let result = await Just((data: Data(), response: response))\n            .setFailureType(to: Error.self)\n            .catchHTTPErrors()\n            .firstValue()\n\n        guard case .failure(let failure) = result else {\n            XCTFail(\"Publisher succeeded, expected failure with HTTPError\")\n            return\n        }\n\n        guard let actualError = failure as? (any HTTPError) else {\n            XCTFail(\"Error: \\(failure) thrown by publisher was not an HTTPError\")\n            return\n        }\n\n        XCTAssertEqual(actualError.statusCode, error.statusCode)\n\n        if case HTTPClientError.tooManyRequests(.some(let retryAfter)) = actualError {\n            XCTAssertEqual(retryAfter.converted(to: .seconds).value, 1.5)\n        } else {\n            XCTFail(\"RetryAfter value not in error.\")\n        }\n    }\n\n    func testRetryAfterServerSpecifiedTime() async throws {\n        let json = try XCTUnwrap(\"\"\"\n        [\n            {\n                userId: 1,\n                id: 1,\n                title: \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",\n                body: \"quia et suscipit suscipit recusandae consequuntur expedita et cum reprehenderit molestiae ut ut quas totam nostrum rerum est autem sunt rem eveniet architecto\"\n            },\n        ]\n        \"\"\".data(using: .utf8))\n        let retryAfter = Double.random(in: 0.100...0.240)\n        let requestDate: Date = Date()\n        StubResponse(on: isAbsoluteURLString(\"https://jsonplaceholder.typicode.com/posts\") && isMethodGET()) { _ in\n            HTTPStubsResponse(data: Data(), statusCode: Int32(HTTPClientError.tooManyRequests().statusCode), headers: [\"Retry-After\": \"\\(retryAfter)\"])\n        }\n        .thenRespond(on: isAbsoluteURLString(\"https://jsonplaceholder.typicode.com/posts\") && isMethodGET()) { _ in\n            HTTPStubsResponse(data: json, statusCode: 200, headers: nil)\n        }\n\n        let api = JSONPlaceholder()\n\n        let value = try await api.get(endpoint: \"posts\")\n            .respondToRateLimiting()\n            .firstValue()\n            .get()\n\n        XCTAssertGreaterThan(Date().timeIntervalSince1970 - requestDate.timeIntervalSince1970, Measurement(value: retryAfter, unit: UnitDuration.milliseconds).converted(to: .seconds).value)\n        XCTAssertEqual(value.response.statusCode, 200)\n        XCTAssertEqual(String(data: value.data, encoding: .utf8), String(data: json, encoding: .utf8))\n    }\n\n    func testRespondToRateLimitingOnlyRetriesOnce() async throws {\n        let retryAfter = Double.random(in: 0.100...0.300)\n        let requestDate: Date = Date()\n        StubResponse(on: isAbsoluteURLString(\"https://jsonplaceholder.typicode.com/posts\") && isMethodGET()) { _ in\n            HTTPStubsResponse(data: Data(), statusCode: Int32(HTTPClientError.tooManyRequests().statusCode), headers: [\"Retry-After\": \"\\(retryAfter)\"])\n        }\n        .thenRespond(on: isAbsoluteURLString(\"https://jsonplaceholder.typicode.com/posts\") && isMethodGET()) { _ in\n            HTTPStubsResponse(data: Data(), statusCode: Int32(HTTPClientError.tooManyRequests().statusCode), headers: [\"Retry-After\": \"\\(retryAfter)\"])\n        }\n        .thenRespond(on: isAbsoluteURLString(\"https://jsonplaceholder.typicode.com/posts\") && isMethodGET()) { _ in\n            XCTFail(\"Should not have made a 3rd request\")\n            return HTTPStubsResponse(data: Data(), statusCode: Int32(HTTPClientError.tooManyRequests().statusCode), headers: [\"Retry-After\": \"\\(retryAfter)\"])\n        }\n\n        let api = JSONPlaceholder()\n\n        var publisherRetries = 0\n        let result = await api.get(endpoint: \"posts\")\n            .map { val in\n                publisherRetries += 1\n                return val\n            }\n            .respondToRateLimiting(maxSecondsToWait: 0)\n            .firstValue()\n\n        XCTAssertGreaterThan(Date().timeIntervalSince1970 - requestDate.timeIntervalSince1970, Measurement(value: retryAfter, unit: UnitDuration.milliseconds).converted(to: .seconds).value)\n        XCTAssertThrowsError(try result.get()) { error in\n            guard let actualError = error as? (any HTTPError) else {\n                XCTFail(\"Error: \\(error) thrown by publisher was not an HTTPError\")\n                return\n            }\n\n            XCTAssertEqual(actualError.statusCode, HTTPClientError.tooManyRequests().statusCode)\n        }\n        XCTAssertEqual(publisherRetries, 2)\n    }\n\n    func testRateLimitingShouldDoNothingUnlessCorrectStatusCodeIsGiven() async throws {\n        let json = try XCTUnwrap(\"\"\"\n        [\n            {\n                userId: 1,\n                id: 1,\n                title: \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",\n                body: \"quia et suscipit suscipit recusandae consequuntur expedita et cum reprehenderit molestiae ut ut quas totam nostrum rerum est autem sunt rem eveniet architecto\"\n            },\n        ]\n        \"\"\".data(using: .utf8))\n        StubResponse(on: isAbsoluteURLString(\"https://jsonplaceholder.typicode.com/posts\") && isMethodGET()) { _ in\n            HTTPStubsResponse(data: json, statusCode: 200, headers: nil)\n        }\n\n        let api = JSONPlaceholder()\n\n        let value = try await api.get(endpoint: \"posts\")\n            .respondToRateLimiting()\n            .firstValue()\n            .get()\n\n        XCTAssertEqual(value.response.statusCode, 200)\n        XCTAssertEqual(String(data: value.data, encoding: .utf8), String(data: json, encoding: .utf8))\n    }\n\n    func testRateLimitingDoesNotRetryIfADifferentErrorIsThrown() async throws {\n        var requestCount = 0\n        StubResponse(on: isAbsoluteURLString(\"https://jsonplaceholder.typicode.com/posts\") && isMethodGET()) { _ in\n            requestCount += 1\n            return HTTPStubsResponse(data: Data(), statusCode: 401, headers: nil)\n        }\n\n        let api = JSONPlaceholder()\n\n        let result = await api.get(endpoint: \"posts\")\n            .respondToRateLimiting()\n            .firstValue()\n\n        XCTAssertThrowsError(try result.get()) {\n            XCTAssertEqual($0 as? HTTPClientError, .unauthorized)\n        }\n\n        XCTAssertEqual(requestCount, 1)\n    }\n}\n```\n\nThere may be a lot of code, but each test is actually quite simple and understandable.\n\n## Wrapping up\nIt's fair to say this probably isn't a beginner-level networking layer. But the power and flexibility of Combine, coupled with the cancellation model make it a really useful tool. This article certainly didn't cover all the details, check out [the git repo](https://github.com/Tyler-Keith-Thompson/RandomSideProjects/tree/main/RESTNetworkLayer) to see even more of how it all came together.",
                                           author: tyler)
        try await restNetworkingLayer.save(on: database)
        try await restNetworkingLayer.$tags.attach([engineering, testing, swift], on: database)
    }
    
    func revert(on database: any Database) async throws {
        
    }
}
